## hw1：好多星星

很基本的題目，用雙層迴圈解決了。
第二層迴圈可以用 `'*'.repeat(n)` 來代替。

## hw2：水仙花數

先用一個迴圈跑 n ~ m 之間的數，一個一個判斷是不是水仙花數；再用另一個迴圈把正在判斷的數字位數拆開，記住有幾位數，用陣列存各個位數的值；最後用 `array.reduce(callback)` 把位數次方加起來，看看總和是不是跟原本數字相等。如果不用 `reduce` 整個程式應該會看起來更亂吧。

## hw3：判斷質數

需要注意的是 1 這個數字需要特別處理，所以先在前面寫了 `if` 判斷。然後用一個迴圈看有沒有除了自己和 1 以外的因數，有就回傳`Composite`。迴圈整個跑完代表沒有因數，所以就回傳 `Prime`。

## hw4：判斷迴文

上週課程的時候就寫過了，那時候好像是先跑一個反向的迴圈記錄反過來的字串，再看正反兩者有沒有相等。

這次改一個方法，跑一個迴圈，在迴圈內直接比對第一個跟最後一個字元、第二個跟倒數第二個字元，以此類推。要再快一點可以設一個判斷，跑到字串中間那個字就 `break`，雖然時間複雜度一樣是 O(n)。

## hw5：聯誼順序比大小

這也是在上週課程先寫的題目，難點是數字位數可能會超級大，所以轉成 `BigInt` 來做運算。如果存成字串來比對也不是不行，只是步驟上會比較麻煩——就從最左邊的位數開始一位一位比較大小。

---

這次沒有使用 jest 來做單元測試，因為主要都直接在 repl.it 這個網站上寫題目，就沒特別安裝 package，不然用起來應該會很卡。
